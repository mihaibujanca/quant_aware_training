#!/usr/bin/env bash
# Generate .context/REPO_MAP.md — lightweight, deterministic repo map.
# No LLMs, no network calls. Uses ripgrep if available, falls back to grep.
set -euo pipefail

OUT=".context/REPO_MAP.md"
mkdir -p .context

# Pick a grep tool
if command -v rg &>/dev/null; then
  RG="rg"
else
  RG="grep -rn"
fi

MAX_SIGS_PER_FILE=30

cat > "$OUT" <<'HEADER'
# Repo Map
<!-- Auto-generated by scripts/make_repo_map.sh — do not hand-edit -->

HEADER

# --- Directory tree (depth 2) ---
{
  echo "## Directory tree"
  echo '```'
  if command -v tree &>/dev/null; then
    tree -L 2 -d --noreport -I '.git|.venv|__pycache__|node_modules|.tox|*.egg-info'
  else
    find . -maxdepth 2 -type d \
      ! -path './.git*' ! -path './.venv*' ! -path '*__pycache__*' \
      ! -path '*node_modules*' | sort
  fi
  echo '```'
  echo ""
} >> "$OUT"

# --- Detect primary language ---
py_count=$(find . -name '*.py' ! -path './.venv/*' ! -path '*__pycache__*' | wc -l | tr -d ' ')
js_count=$(find . -name '*.js' -o -name '*.ts' ! -path '*node_modules*' 2>/dev/null | wc -l | tr -d ' ')
rs_count=$(find . -name '*.rs' 2>/dev/null | wc -l | tr -d ' ')

# --- Key modules ---
{
  echo "## Key files"
  echo '```'
  # Top-level Python files
  ls -1 *.py 2>/dev/null | head -10 || true
  # Package directories (look for __init__.py at depth 1-2)
  find . -maxdepth 2 -name '__init__.py' ! -path './.venv/*' \
    -exec dirname {} \; 2>/dev/null | sort | sed 's|^\./||'
  echo '```'
  echo ""
} >> "$OUT"

# --- Public API signatures (Python) ---
if [ "$py_count" -gt 0 ]; then
  {
    echo "## Public API signatures"
    echo ""

    # Directories to scan: known package dirs + top-level .py
    SCAN_DIRS=""
    for d in aleph src lib app; do
      [ -d "$d" ] && SCAN_DIRS="$SCAN_DIRS $d"
    done

    # Scan package directories
    for dir in $SCAN_DIRS; do
      echo "### ${dir}/"
      echo '```python'
      $RG --no-filename -n '^(class |def |async def )' "$dir" \
        --glob '*.py' 2>/dev/null \
        | grep -v '^\s*def _' \
        | head -80 || true
      echo '```'
      echo ""
    done

    # Top-level scripts (abbreviated)
    toplevel_py=$(ls -1 *.py 2>/dev/null | head -5)
    if [ -n "$toplevel_py" ]; then
      echo "### Top-level scripts"
      echo '```python'
      for f in $toplevel_py; do
        $RG -n '^(class |def )' "$f" 2>/dev/null | head -"$MAX_SIGS_PER_FILE" || true
      done
      echo '```'
      echo ""
    fi
  } >> "$OUT"
fi

# --- Cap output ---
line_count=$(wc -l < "$OUT")
if [ "$line_count" -gt 400 ]; then
  head -400 "$OUT" > "${OUT}.tmp"
  echo "" >> "${OUT}.tmp"
  echo "_[Truncated at 400 lines]_" >> "${OUT}.tmp"
  mv "${OUT}.tmp" "$OUT"
fi

echo "Wrote $OUT ($line_count lines)"
